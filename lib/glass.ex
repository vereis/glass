defmodule Glass do
  @moduledoc "README.md" |> File.read!() |> String.trim() |> String.trim_leading("# Glass\n")

  @doc false
  defmacro __using__(_opts) do
    quote do
      import unquote(__MODULE__)

      require unquote(__MODULE__)
    end
  end

  @doc """
  Defines a new Glass proxy module for the given module alias.

  ## Examples

  Assuming you have a module `ReportingService` in another application `MyOtherApp`, which
  is deployed in another release in a different node in your cluster, you can't directly
  call functions in that module from your current application.

  By defining a Glass proxy module, you can transparently call functions in `ReportingService`,
  in this case, via `:rpc`.

      defglass ReportingService, via: Glass.Methods.RPC

  Following this, all calls to `ReportingService` will be transparently proxied via `:rpc`,
  but these appear to the reader as completely normal, local function calls.

  Additionally, you can add debug logging to your Glass proxy functions to aide in debugging:

      defglass ReportingService, via: Glass.Methods.Apply, debug: true

  And you can also make the proxy module public, if you need to access it directly or via
  the REPL.

      defglass ReportingService, via: Glass.Methods.Apply, private: false

  ## Options

  * `:via` - The method to use for calling proxied functions. Defaults to `Glass.Methods.Apply`.
  * `:private` - Whether or not to generate the proxy module as private. Defaults to `true`.
  * `:debug` - Whether or not to generate proxy debug information. Defaults to `false`.
  * `:as` - The alias to use for the proxied module. If not provided, the proxy module must be called
    directly by the full name of the original module.

  ## See Also

  * The `Glass.Method` behaviour, which is the interface that must be matched for any `:via` method.
  * The `Glass.Methods.Apply` method, which is the simplest possible method you can implement.
  * The `Glass.Methods.RPC` method, which is a more complex method that uses `:rpc` to call functions.

  """
  defmacro defglass({:__aliases__, _location, [namespace | _] = alias}, opts \\ []) do
    # Name of the proxy module we create under the .Glass namespace
    # i.e. `Elixir.MyApp.Users.Glass.MyOtherApp.Reporting.Excel`
    module =
      __CALLER__.module
      |> List.wrap()
      |> Enum.concat([Glasses | alias])
      |> Module.concat()

    # Top-level .Glass.* namespace for proxy modules
    # i.e. `Elixir.MyApp.Users.Glass.MyOtherApp`
    namespace =
      __CALLER__.module
      |> List.wrap()
      |> Enum.concat([Glasses, namespace])
      |> Module.concat()

    # Local alias to shadow the original module with proxy namespace
    # i.e. `Elixir.MyOtherApp`
    as_namespace =
      Keyword.get(
        opts,
        :as,
        Module.concat(
          :"Elixir",
          namespace
          |> Module.split()
          |> List.last()
        )
      )

    # Method to use for calling proxied functions via Glass proxy
    via = Keyword.get(opts, :via, Glass.Methods.Apply)

    # Whether or not to generate proxy module as private
    private? = Keyword.get(opts, :private, true)

    # Whether or not to generate proxy debug information
    debug? = Keyword.get(opts, :debug, false)

    quote location: :keep do
      alias unquote(namespace), as: unquote(as_namespace)

      defmodule unquote(module) do
        @moduledoc unquote(
                     (!private? &&
                        """
                        This module was automaticallu generated by `Glass` and is a proxy for
                        calling functions in `#{inspect(Module.concat(alias))}` via `#{inspect(via |> elem(2) |> Module.concat())}`
                        transparently in `#{inspect(__CALLER__.module)}`.

                        For documentation on what functions are available, please refer to the documentation
                        for `#{inspect(Module.concat(alias))}` instead.

                        This module is private and should not be used directly -- `Glass` should handle all
                        proxying for you transparently.
                        """) || false
                   )

        require Logger

        @module unquote(Module.concat(alias))

        @doc false
        def unquote(:"$handle_undefined_function")(function, args) do
          if unquote(debug?) do
            Logger.debug("""
            Glass: Proxying call to `#{inspect(@module)}.#{function}/#{length(args)}`...
              args:   #{inspect(args, charlists: false)}
              glass:  `#{inspect(__MODULE__)}`
              via:    `#{inspect(unquote(via))}`
            """)
          end

          unquote(via).handle_proxy(@module, function, args)
        end
      end
    end
  end
end
